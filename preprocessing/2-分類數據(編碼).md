```python
import pandas as pd
import numpy as np

df = pd.DataFrame([
['green','M',10.1,'class1'],
['red','X',13.5,'class2'],
['blue','XL',15.3,'class1']
])

df.columns = ['color','size','price','classlabel']

   color size  price classlabel
0  green    M   10.1     class1
1    red    X   13.5     class2
2   blue   XL   15.3     class1


# 有序特徵 : 將size轉為有序數字
size_mapping = {
'XL':5,
'X':4,
'M':3,
'S':2,
'XS':1
}


# 取一欄df.iloc[:,0] 也可
# 取多欄 df[['ColA','ColB']] or df.iloc[:,[0:3]] or df.iloc[:,[0,2]]
# 用map函式轉值
df['size']=df['size'].map(size_mapping) 

   color  size  price classlabel
0  green     3   10.1     class1
1    red     4   13.5     class2
2   blue     5   15.3     class1


# 反轉 mapping (dictionary comprehesion 方法)
inv_size_mapping = {v: k for k, v in size_mapping.items()}


# 無序特徵 : 將classlabel轉為數字(PS. 順序不重要，所以隨意給即可)
# enumerate有list/array加上索引， 底部有補充
# 如要反轉，同上方式
class_mapping = {
label: idx for idx, label in
enumerate(np.unique(df['classlabel']))
}

{'class1': 0, 'class2': 1}

df['classlabel'] = df['classlabel'].map(class_mapping)
   color  size  price  classlabel
0  green     3   10.1           0
1    red     4   13.5           1
2   blue     5   15.3           0

# 無序特徵 : sklearn 提供的方法
from sklearn.preprocessing import LabelEncoder
class_le = LabelEncoder()
# fit & transform 是兩個方法，但可以一次就執行
# fit 會將編碼表寫到自身變式，以利後續反轉

df['classlabel'] = class_le.fit_transform(df['classlabel'].values)
df['classlabel'] = class_le.inverse_transform(df['classlabel'].values)

# 一次要轉多欄
X = df[['color', 'size', 'classlabel']].values
X[:,0] = class_le.fit_transform(X[:,0])

# 















#####    enumerate   補 充  ############
>>>i = 0
>>> seq = ['one', 'two', 'three']
>>> for element in seq:
...     print i, seq[i]
...     i +=1
... 
0 one
1 two
2 three

>>>seq = ['one', 'two', 'three']
>>> for i, element in enumerate(seq):
...     print i, seq[i]
... 
0 one
1 two
2 three

###############################



```
